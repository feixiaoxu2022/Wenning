# 工具封装 vs 代码生成架构决策

## 文档概述

本文档定义创作Agent中工具实现的架构策略，解决"何时封装工具 vs 何时让LLM写代码"的核心决策问题。

---

## 1. 问题背景

创作Agent需要处理图像、视频、PPT等多种类型的内容创作任务，涉及大量Python库（PIL、OpenCV、ffmpeg、python-pptx等）。有两种实现路径：

**方案A: 工具封装**
- 将常用操作封装为Function Calling工具
- 示例: `compose_cover(template, title, background, style)`

**方案B: 代码生成**
- 保留通用的`execute_python(code)`工具
- LLM根据需求动态生成Python代码执行

两种方案各有优劣，需要明确的决策原则。

---

## 2. 方案对比分析

### 2.1 多维度对比矩阵

| 维度 | 工具封装 | 代码生成 | 权重 | 加权得分 |
|------|---------|---------|------|---------|
| **灵活性** | ❌ 低 (受限于预定义参数) | ✅ 极高 (任意Python能力) | 20% | 封装:2 生成:5 |
| **可控性** | ✅ 高 (参数明确、可验证) | ⚠️ 中 (依赖LLM代码质量) | 25% | 封装:5 生成:3 |
| **开发成本** | ❌ 高 (每个功能需单独封装) | ✅ 低 (复用execute_python) | 15% | 封装:2 生成:5 |
| **调试难度** | ✅ 低 (逻辑在工具内部) | ❌ 高 (需检查生成代码) | 20% | 封装:5 生成:2 |
| **性能优化** | ✅ 易 (工具内可缓存优化) | ❌ 难 (每次重新生成) | 10% | 封装:5 生成:2 |
| **用户体验** | ✅ 好 (进度可追踪、错误明确) | ⚠️ 一般 (黑盒执行) | 20% | 封装:5 生成:3 |
| **迭代速度** | ❌ 慢 (修改需改源码) | ✅ 快 (Prompt调整即可) | 15% | 封装:2 生成:5 |

**加权总分**:
- 工具封装: 3.85/5
- 代码生成: 3.45/5

**结论**: 纯粹从评分看封装略优，但不应二选一，**应该分层混合使用**。

---

## 3. 推荐方案: 三层混合架构

### 3.1 架构层次

```
┌─────────────────────────────────────────────────┐
│ 第三层: 代码生成 (长尾、定制化需求)              │
│ execute_python(code)                            │
│ - 特殊图像效果 (手绘风格转换)                    │
│ - 复杂数据可视化                                 │
│ - 实验性功能快速验证                             │
└────────────────┬────────────────────────────────┘
                 │ 调用
┌────────────────▼────────────────────────────────┐
│ 第二层: 组合工具 (业务场景封装)                  │
│ - generate_cover_image(template, title, ...)    │
│ - create_ppt_from_outline(outline, template)    │
│ - batch_process_images(dir, operations)         │
└────────────────┬────────────────────────────────┘
                 │ 组合调用
┌────────────────▼────────────────────────────────┐
│ 第一层: 原子工具 (高频、关键路径)                │
│ - resize_image(path, width, height, mode)       │
│ - add_text_to_image(img, text, pos, font, ...)  │
│ - apply_image_filter(img, filter_name)          │
│ - extract_video_segment(video, start, end)      │
└─────────────────────────────────────────────────┘
```

### 3.2 分层职责说明

**第一层: 原子工具**
- 职责: 提供最基础、高频的操作单元
- 特点: 参数简单、执行快速、结果稳定
- 示例: 图片缩放、文字添加、滤镜应用
- 封装库: PIL/Pillow, OpenCV, ffmpeg简单命令

**第二层: 组合工具**
- 职责: 封装完整业务场景的执行逻辑
- 特点: 调用多个原子工具、包含业务规则
- 示例: 封面生成(背景处理+文字排版+风格应用)
- 封装层级: 调用第一层工具 + 模板系统

**第三层: 代码生成**
- 职责: 处理非标准、定制化、低频需求
- 特点: 高度灵活、快速迭代、覆盖边界
- 示例: 用户要求"图片转手绘风格"(非标准滤镜)
- 实现方式: LLM生成完整Python代码执行

---

## 4. 决策原则

### 4.1 封装为工具的条件

满足以下**任意2条**即应封装为工具:

1. **高频使用** (Frequency)
   - 80%的任务场景都会用到
   - 示例: `resize_image` - 几乎所有图像处理都需要

2. **性能敏感** (Performance)
   - 需要优化执行速度或资源消耗
   - 示例: 批量图片处理时的并发控制

3. **质量关键** (Quality Critical)
   - 直接影响最终交付物质量
   - 示例: `add_text_to_image` - 字体渲染、抗锯齿处理

4. **需要状态管理** (Stateful)
   - 涉及缓存、进度追踪、资源池管理
   - 示例: `download_large_file` - 断点续传、进度回调

5. **安全边界** (Safety Critical)
   - 需要参数校验、资源限制、超时控制
   - 示例: `execute_video_processing` - 防止超大文件卡死

### 4.2 使用代码生成的场景

1. **探索性需求** (Exploratory)
   - 用户第一次尝试某种效果，不确定是否高频
   - 示例: "给我生成一个复古老照片效果"

2. **定制化强** (Highly Customized)
   - 参数组合复杂，难以标准化为工具接口
   - 示例: 用户要求特定的图表样式(多种配色/布局组合)

3. **低频长尾** (Long Tail)
   - 可能只用一次的特殊操作
   - 示例: "把logo放在右下角，旋转15度，半透明"

4. **快速迭代** (Rapid Prototyping)
   - MVP阶段验证功能可行性
   - 示例: 测试某个新功能是否有用户需求

### 4.3 决策流程图

```
需求分析
    ↓
是否高频使用? ────No──→ 是否性能敏感? ────No──→ 使用代码生成
    ↓ Yes                    ↓ Yes
是否质量关键? ────No──→ 封装为工具
    ↓ Yes
封装为工具
```

---

## 5. 实战案例

### 5.1 案例1: 封面图生成

**需求**: 根据标题和背景图生成视频封面

**决策过程**:
- ✅ 高频使用: 内容创作者每天需要生成多个封面
- ✅ 质量关键: 直接影响视频点击率
- ✅ 需要状态管理: 模板加载、字体缓存

**决策结果**: 封装为组合工具

**实现层次**:
```python
# 第二层: 组合工具
def compose_cover(template: str, title: str, subtitle: str,
                  background: str, style_overrides: Dict = None) -> Dict:
    """封面生成 - 调用多个原子工具"""
    # 1. 加载模板配置
    config = load_template(template)

    # 2. 背景处理 (调用第一层工具)
    bg = resize_image(background, 1920, 1080, mode="cover")
    bg = apply_image_filter(bg, config['bg_filter'])

    # 3. 文字渲染 (调用第一层工具)
    canvas = add_text_to_image(
        bg, title,
        position=config['title_position'],
        font=config['title_font'],
        size=config['title_size'],
        color=style_overrides.get('title_color', config['title_color'])
    )

    # 4. 生成多个候选
    variants = []
    for scheme in config['color_variants']:
        variant = apply_color_scheme(canvas, scheme)
        variants.append(variant)

    return {"variants": variants, "recommended": variants[0]}

# 第一层: 原子工具
def resize_image(path: str, width: int, height: int, mode: str = "cover") -> Image:
    """图片缩放 - PIL封装"""
    img = Image.open(path)
    if mode == "cover":
        # 填充模式：保持比例，裁剪多余部分
        ...
    elif mode == "contain":
        # 包含模式：保持比例，留白边
        ...
    return resized_img

def add_text_to_image(img: Image, text: str, position: Tuple,
                      font: str, size: int, color: str) -> Image:
    """文字添加 - 高质量渲染"""
    draw = ImageDraw.Draw(img)
    font_obj = ImageFont.truetype(font, size)
    # 文字描边、阴影处理...
    draw.text(position, text, fill=color, font=font_obj)
    return img
```

### 5.2 案例2: 特殊图像效果

**需求**: 用户要求"把这张图转成油画风格"

**决策过程**:
- ❌ 低频使用: 不是常见需求
- ❌ 参数复杂: 油画效果有多种实现方式
- ✅ 快速迭代: 可能尝试后发现不合适

**决策结果**: 使用代码生成

**实现方式**:
```python
# LLM生成代码
execute_python("""
from PIL import Image, ImageFilter
import cv2
import numpy as np

# 读取图片
img = cv2.imread('input.jpg')

# 方法1: 使用双边滤波 + 边缘增强
bilateral = cv2.bilateralFilter(img, 9, 75, 75)
edges = cv2.Canny(img, 100, 200)
# ... 油画效果处理

# 保存结果
cv2.imwrite('output_oil_painting.jpg', result)
print('油画效果已生成')
""")
```

**优势**:
- 快速实现(无需封装工具)
- 用户不满意可以快速调整代码
- 如果后续高频使用，再考虑封装

---

## 6. 迁移策略

### 6.1 从代码生成到工具封装

当发现某个代码生成的操作变成高频需求时，应迁移为工具：

**触发条件**:
- 同一操作在7天内被调用 ≥ 3次
- 或者被不同用户调用 ≥ 2次

**迁移步骤**:
1. 分析历史生成的代码，提取共性参数
2. 设计工具接口(函数签名)
3. 实现工具并测试
4. 更新System Prompt，引导Agent优先使用新工具
5. 保留代码生成作为兜底(处理边界情况)

**示例**:
```python
# 迁移前: 每次生成代码
execute_python("""
from PIL import Image
img = Image.open('input.jpg')
img = img.resize((800, 600))
img = img.convert('RGB')
img.save('output.jpg', quality=90)
""")

# 迁移后: 封装为工具
resize_and_optimize(
    input='input.jpg',
    output='output.jpg',
    size=(800, 600),
    quality=90
)
```

### 6.2 保持代码生成的灵活性

即使封装了工具，也要保留代码生成能力处理：

1. **工具的组合使用** - LLM可以生成代码调用多个工具
2. **工具的参数超出预设范围** - 通过代码实现更复杂的参数逻辑
3. **工具的bug修复** - 在工具修复前，代码可以绕过问题
4. **A/B测试新功能** - 先用代码实现，验证后再封装

---

## 7. 实施建议

### 7.1 MVP阶段 (Week 1-4)

**策略**: 最小化工具封装，优先验证需求

**封装清单** (仅封装5个核心工具):
1. `analyze_image(path, type)` - Vision能力必需
2. `search_stock_images(query)` - 素材获取核心
3. `compose_cover(template, ...)` - 封面生成主流程
4. `resize_image(path, size)` - 高频原子操作
5. `add_text_to_image(img, text, ...)` - 质量关键

**其他操作**: 全部使用`execute_python`代码生成

### 7.2 V1.0阶段 (Week 5-8)

**策略**: 基于数据决策，封装高频操作

**数据收集**:
- 统计`execute_python`调用中的代码模式
- 分析哪些操作频次 > 阈值
- 识别用户反馈中的痛点(调试困难、速度慢等)

**新增工具** (预计5-10个):
- 批量图片处理工具集
- 视频处理基础工具
- PPT生成工具

### 7.3 V2.0阶段 (Week 9+)

**策略**: 完善工具体系，优化性能

**优化方向**:
- 工具内部优化(缓存、并发、GPU加速)
- 工具智能推荐(根据上下文自动选工具)
- 工具错误恢复(失败自动降级到代码生成)

---

## 8. 监控指标

### 8.1 工具使用情况

```python
# 监控指标定义
metrics = {
    "tool_usage_ratio": "工具调用次数 / (工具+代码生成总次数)",
    "tool_success_rate": "工具执行成功次数 / 工具调用次数",
    "code_gen_retry_rate": "代码生成失败重试次数 / 代码生成次数",
    "user_satisfaction": "用户满意度评分(1-5分)"
}

# 健康阈值
healthy_thresholds = {
    "tool_usage_ratio": "> 60%",  # 工具调用占比应高于60%
    "tool_success_rate": "> 95%",  # 工具成功率应高于95%
    "code_gen_retry_rate": "< 20%",  # 代码重试率应低于20%
    "user_satisfaction": "> 4.0"  # 用户满意度应高于4分
}
```

### 8.2 迁移决策指标

```python
# 决策是否将代码生成迁移为工具
def should_migrate_to_tool(operation_stats: Dict) -> bool:
    """
    operation_stats = {
        "frequency_7d": 5,  # 7天内调用次数
        "unique_users": 3,  # 不同用户数
        "avg_exec_time": 2.5,  # 平均执行时间(秒)
        "retry_rate": 0.15  # 重试率
    }
    """
    if operation_stats["frequency_7d"] >= 3:
        return True
    if operation_stats["unique_users"] >= 2:
        return True
    if operation_stats["retry_rate"] > 0.2:
        return True  # 代码生成质量不稳定
    return False
```

---

## 9. 总结

### 核心原则

1. **不是二选一，而是分层共存**
   - 第一层原子工具保证基础能力
   - 第二层组合工具封装业务场景
   - 第三层代码生成提供灵活性

2. **封装决策基于数据，而非猜测**
   - 高频(F) + 质量关键(Q) + 性能敏感(P) → 封装
   - 低频 + 定制化 + 快速迭代 → 代码生成

3. **动态调整，持续优化**
   - 代码生成 → 高频验证 → 迁移为工具
   - 工具 → 发现局限 → 增强或拆分

### 决策公式

```
封装价值 = 频率 × 质量影响 × 性能收益 - 开发维护成本

if 封装价值 > 阈值:
    封装为工具
else:
    使用代码生成
```

### 实施路径

```
MVP: 5个核心工具 + execute_python兜底
  ↓ 数据驱动决策
V1.0: 10-15个工具 + 代码生成(长尾30%)
  ↓ 性能优化 + 智能推荐
V2.0: 完善工具体系 + 自动工具生成
```

---

**文档版本**: v1.0
**最后更新**: 2025-11-10
**负责人**: 架构组
**审核状态**: ✅ 已审核
